import { execSync, exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';
import { logger } from './logger.js';
import { GROUPS_DIR } from './config.js';
import { readEnvFile } from './env.js';

const execAsync = promisify(exec);

interface GitBackupConfig {
  repoUrl: string;
  branch: string;
  gitName: string;
  gitEmail: string;
}

function getConfig(): GitBackupConfig {
  const env = readEnvFile([
    'GIT_BACKUP_REPO',
    'GIT_BACKUP_BRANCH',
    'GIT_BACKUP_NAME',
    'GIT_BACKUP_EMAIL',
  ]);
  return {
    repoUrl: env.GIT_BACKUP_REPO || '',
    branch: env.GIT_BACKUP_BRANCH || 'main',
    gitName: env.GIT_BACKUP_NAME || 'NanoClaw Backup',
    gitEmail: env.GIT_BACKUP_EMAIL || 'backup@nanoclaw.local',
  };
}

/**
 * 检查 Git 备份是否已配置
 */
export function isGitBackupConfigured(): boolean {
  const config = getConfig();
  return !!config.repoUrl;
}

/**
 * 初始化 Git 仓库（如果不存在）
 */
export async function initGitBackup(): Promise<void> {
  const config = getConfig();

  if (!config.repoUrl) {
    throw new Error('Git backup not configured. Set GIT_BACKUP_REPO env var.');
  }

  const gitDir = path.join(GROUPS_DIR, '.git');

  // 如果已经初始化，跳过
  if (fs.existsSync(gitDir)) {
    logger.debug('Git backup already initialized');
    return;
  }

  logger.info({ repo: config.repoUrl }, 'Initializing Git backup');

  try {
    // 初始化仓库
    execSync('git init', { cwd: GROUPS_DIR, stdio: 'ignore' });

    // 配置 Git
    execSync(`git config user.name "${config.gitName}"`, {
      cwd: GROUPS_DIR,
      stdio: 'ignore',
    });
    execSync(`git config user.email "${config.gitEmail}"`, {
      cwd: GROUPS_DIR,
      stdio: 'ignore',
    });

    // 添加远程仓库
    execSync(`git remote add origin ${config.repoUrl}`, {
      cwd: GROUPS_DIR,
      stdio: 'ignore',
    });

    // 创建 .gitignore，排除不需要备份的文件
    const gitignorePath = path.join(GROUPS_DIR, '.gitignore');
    const gitignoreContent = `
# Auto-generated by NanoClaw
*.log
logs/
.venv/
node_modules/
__pycache__/
*.pyc
*.pyo
.DS_Store
*.tmp
*.bak
`;
    fs.writeFileSync(gitignorePath, gitignoreContent.trim());

    logger.info('Git backup initialized successfully');
  } catch (err) {
    logger.error({ err }, 'Failed to initialize Git backup');
    throw err;
  }
}

/**
 * 备份文件记忆到 Git
 */
export async function backupToGit(): Promise<void> {
  if (!isGitBackupConfigured()) {
    logger.debug('Git backup not configured, skipping');
    return;
  }

  const config = getConfig();

  try {
    // 确保已初始化
    await initGitBackup();

    // 检查是否有变更
    const { stdout: status } = await execAsync('git status --porcelain', {
      cwd: GROUPS_DIR,
    });

    if (!status.trim()) {
      logger.debug('No changes to backup');
      return;
    }

    // 添加所有变更
    execSync('git add -A', { cwd: GROUPS_DIR, stdio: 'ignore' });

    // 提交
    const timestamp = new Date().toISOString();
    const commitMessage = `backup: auto sync memory files\n\nTimestamp: ${timestamp}`;

    execSync(`git commit -m "${commitMessage}"`, {
      cwd: GROUPS_DIR,
      stdio: 'ignore',
    });

    // 推送到远程
    execSync(`git push origin ${config.branch}`, {
      cwd: GROUPS_DIR,
      stdio: 'ignore',
    });

    logger.info('Memory files backed up to Git');
  } catch (err) {
    logger.error({ err }, 'Git backup failed');
    // 不抛出错误，避免影响主流程
  }
}

/**
 * 从 Git 恢复文件记忆
 */
export async function restoreFromGit(): Promise<void> {
  if (!isGitBackupConfigured()) {
    throw new Error('Git backup not configured');
  }

  const config = getConfig();

  logger.info({ repo: config.repoUrl }, 'Restoring memory files from Git');

  try {
    // 如果目录已存在，先备份
    const backupDir = `${GROUPS_DIR}.local-backup-${Date.now()}`;
    if (fs.existsSync(GROUPS_DIR)) {
      fs.renameSync(GROUPS_DIR, backupDir);
      logger.info({ backupDir }, 'Local groups backed up');
    }

    // 克隆仓库
    execSync(`git clone ${config.repoUrl} ${GROUPS_DIR}`, {
      stdio: 'ignore',
    });

    // 切换到指定分支
    execSync(`git checkout ${config.branch}`, {
      cwd: GROUPS_DIR,
      stdio: 'ignore',
    });

    logger.info('Memory files restored from Git');
  } catch (err) {
    logger.error({ err }, 'Git restore failed');
    throw err;
  }
}

/**
 * 获取 Git 备份状态
 */
export async function getGitBackupStatus(): Promise<{
  configured: boolean;
  initialized: boolean;
  hasChanges: boolean;
  lastCommit?: string;
}> {
  const config = getConfig();
  const gitDir = path.join(GROUPS_DIR, '.git');

  if (!config.repoUrl) {
    return { configured: false, initialized: false, hasChanges: false };
  }

  if (!fs.existsSync(gitDir)) {
    return { configured: true, initialized: false, hasChanges: false };
  }

  try {
    // 检查是否有未提交的变更
    const { stdout: status } = await execAsync('git status --porcelain', {
      cwd: GROUPS_DIR,
    });

    // 获取最后一次提交
    let lastCommit: string | undefined;
    try {
      const { stdout: commit } = await execAsync('git log -1 --format=%cd', {
        cwd: GROUPS_DIR,
      });
      lastCommit = commit.trim();
    } catch {
      // 可能没有提交历史
    }

    return {
      configured: true,
      initialized: true,
      hasChanges: !!status.trim(),
      lastCommit,
    };
  } catch (err) {
    return { configured: true, initialized: true, hasChanges: false };
  }
}

// 默认导出所有功能
export default {
  isGitBackupConfigured,
  initGitBackup,
  backupToGit,
  restoreFromGit,
  getGitBackupStatus,
  startGitBackupScheduler,
};

/**
 * 设置定期自动备份
 * @param intervalMinutes 备份间隔（分钟）
 */
export function startGitBackupScheduler(intervalMinutes: number = 60): void {
  if (!isGitBackupConfigured()) {
    logger.warn('Git backup not configured, scheduler not started');
    return;
  }

  logger.info({ intervalMinutes }, 'Starting Git backup scheduler');

  // 立即执行一次
  backupToGit().catch((err) =>
    logger.error({ err }, 'Initial Git backup failed'),
  );

  // 定期执行
  setInterval(
    () => {
      backupToGit().catch((err) =>
        logger.error({ err }, 'Scheduled Git backup failed'),
      );
    },
    intervalMinutes * 60 * 1000,
  );
}
